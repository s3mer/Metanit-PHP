<?php

		#+--------------------------------+
		#|          PHP 8.1.4             |
		#+--------------------------------+

#######################[Базовые возможности PHP]################################
		
//=====================[Подключение внешних файлов]=============================

	//-----------------[Инструкция include]-------------------------------------

	//include "welcome.php"; // относительный путь

	//$name = "Eugene";
	//welcome($name);

	/* При этом вставка файла должна происходить до использования функции, 
	определенной в этом файле. При этом в данном случае файл welcome.php и файл, 
	в который он подключается, располагаются в одной папке. */

	//include "scripts/welcome.php"; // относительный путь
	//include "/home/eugene/localhost/metanit-php/scripts/welcome.php"; // абсолютный путь

	//$name1 = "Maria";
	//welcome1($name1);

	//-----------------[Инструкция include_once]--------------------------------

	/* Чтобы исключить повторное подключение файла, вместо инструкции include 
	следует применять инструкцию include_once */

	//include_once "welcome.php";

	//$name2 = "Roma";
	//welcome($name2);

	/* если мы подключим этот же файл с помощью include_once еще где-нибудь 
	ниже, то это подключение будет проигнорировано, так как файл уже подключен 
	в программу. */

	//-----------------[Инструкции require и require_once]----------------------

	/* Действие инструкции require подобно инструкции include: она также 
	подключает внешний файл, вставляя в программу его содержимое. Только теперь, 
	если данный файл не будет найден, действие программы прекратится 
	(инструкция include в этом случае выбрасывает предупреждение) */

	//require "welcome.php";
	//welcome($name);

	/* И также если у нас в коде встретятся несколько инструкций require, 
	которые подключают один и тот же файл, то интерпретатор выдаст ошибку. И 
	также чтобы избежать данной ситуации, следует использовать инструкцию 
	require_once */

	//require_once "welcome.php";
	//welcome($name1);

	//-----------------[Функция spl_autoload_register]--------------------------

	/* В качестве параметра spl_autoload_register принимает функцию 
	автозагрузки. Эта функция автоматически вызывается, когда в программе 
	начинает использоваться неизвестный класс или интерфейс. И функция 
	автозагруки пытается загрузить этот класс или интерфейс. В качестве 
	параметра функция автозагрузки принимает название класса или интерфейса, 
	которые надо загрузить. */

	//function my_autoloader($class)
	//{
		//echo "Вызов функции автозагрузки <br>";
		//include $class . ".php";
	//}

	//spl_autoload_register("my_autoloader");

	//$eugene = new Person("Eugene", 25);
	//$eugene -> printInfo();

	/* Например, в данном случае используется класс Person, который в этом 
	скрипте не определен. И когда программа встретит использование данного 
	класса, она вызовет функцию my_autoloader(), в качестве параметра $class 
	передаст в нее название класса Person. 

	При этом в данном случае неважно какой класс, главное, чтобы он хранился в 
	одноименном файле с расширением .php */

//=====================[Пространства имен]======================================

	/* Если какая-то конструкция (например, класс или функция) определена вне 
	любого пространства имен, то считается, что она расположена в глобальном 
	пространстве имен. */

	//-----------------[Определение пространства имен]--------------------------

	/* namespace base; // <--

	class Person1
	{
		public $name;
		function __construct($name) { $this -> name = $name; }
	} 
	?> 

	<!DOCTYPE html>
	<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>METANIT.COM</title>
	</head>
	<body>
		<?php
			//$tom = new Person1("Tom");
			//echo $tom->name;
		?>
	</body>
	</html>

	<?php */

	/* Обычно названия пространств указываются в нижнем регистре. Все, что 
	расположено ниже этой директивы, относится к пространству имен "base". 
	То есть класс Person принадлежит пространству имен base. */

	/* Определение пространства имен должно быть расположено выше любого 
	другого кода или разметки html */

	//-----------------[Обращение к пространству имен]--------------------------
	//namespace work;
	//include "Person2.php";
	//$bob = new \base\Person2("Bob"); // укаываем название пространства имен
	//echo $bob -> name;

	/* Если конструкции одного пространства имен используются в другом 
	пространстве имен (в том числе в глобальном пространстве имен), то перед 
	названием конструкции указывается название ее пространства имен. 

	Без указания пространства имен мы можем использовать конструкцию только в 
	том же пространстве имен, в котором она определена. */

	//-----------------[Вложенные пространства имен]----------------------------

	//namespace work;
	//include "Person3.php";
	//$sam = new \base\classes\Person3("Sam");
	//echo $sam -> name;

	//-----------------[Псевдонимы]---------------------------------------------

	//namespace work;
	//include "Person3.php";

	// установка псевдонима
	/* use \base\classes\Person3 as User;

	$jim = new User("Jim");
	echo $jim -> name . "<br>";
	$dave = new User("Dave");
	echo $dave -> name; */

    /* Можно использовать только конструкцию use без указания псевдонима. 
    Тогда класс можно будет исользовать по его непосредственному имени */

	/* use \base\classes\Person3;

	$jim = new Person3("Jim");
	echo $jim -> name . "<br>";
	$dave = new Person3("Dave");
	echo $dave -> name; */

	//-----------------[Подключение множества классов]--------------------------

	/* namespace work;
	include "Person3.php";

	use \base\classes\Person3 as User, \base\classes\Employee as Employee;
	// или сокращенно
	//use \base\classes\{Person3 as User, Employee as Employee};

	$jim = new User("Jim");
	echo $jim -> name . "<br>";
	$dave = new Employee("Dave");
	echo $dave -> name; */

	//-----------------[Подключение констант и функций]-------------------------

	/*namespace work;
	include "Person4.php";

	use \base\classes\Person4;
	use const \base\classes\adminName;
	use function \base\classes\printPerson;

	$yevhenii = new Person4(adminName);
	printPerson($yevhenii); // Eugene  */

//=====================[Типизация данных]=======================================

	function isPositive($number) // не типизированный параметр функции
	{
		return $number > 0;
	}

	$result = isPositive("-Youdontknowwhoiam");
	//if ($result) echo "положительное";
	//else echo "отрицательное или равно нулю"; // <--

	//-----------------[Определение типа]---------------------------------------

	/* Какие определения типов могут использоваться при типизации:

	bool: допустимые значения true и false

	float: значение должно представлять число с плавающей точкой

	int: значение должно представлять целое число

	string: значение должно представлять строку

	mixed: любое значение

	callable: значение должно представлять функцию

	array: значение должно представлять массив

	iterable: значение должно представлять массив или класс, который реализует 
	интерфейс Traversable. Применяется при переборе в цикле foreach

	Имя класса: объект должен представлять данный класс или его производные классы

	Имя интерфейса: объект должен представлять класс, который реализует данный интерфейс

	Self: объект должен представлять тот же класс или его производный класс. 
	Может использоваться только внутри класса.

	parent: объект должен представлять родительский класс данного класса. 
	Может использоваться только внутри класса. */

	//-----------------[Типизация параметров функции]---------------------------

	function isPositive1(int $number)
	{
		return $number > 0;
	}

	$result1 = isPositive1(25); // OK - 25 число
	$result2 = isPositive1("25"); // OK - PHP может преобразовать значение в число
	$result3 = isPositive("-Youdontknowwhoiam"); // Fatal error: Uncaught TypeError

	// another example
	function sum(array $numbers, callable $condition)
	{
		$result = 0;
		foreach($numbers as $number)
		{
			if($condition($number))
			{
				$result += $number;
			}
		}
		return $result;
	}

	$isPositive = function($n) { return $n > 0; };

	$myNumbers = [-2, -1, 0, 1, 2, 3, 4, 5];
	$positiveSum = sum($myNumbers, $isPositive);
	//echo $positiveSum; //15

	//-----------------[Типизация возвращаемого значения]-----------------------

	function isPositive2(int $number) : bool
	{
		return $number > 0;
	}

	$result4 = isPositive2(36);
	//var_dump($result4); //bool(true)


	// another example - возвращение функции
	function select($n): callable
	{
		switch($n){
			case 1: return function($a, $b) {return $a + $b; };
			case 2: return function($a, $b) {return $a - $b; };
			case 3: return function($a, $b) {return $a * $b; };
			default: return function($a, $b) {return $a . " " . $b; };
		}
	}

	$selection = select(2);
	//echo $selection(4,5); // -1


	/* стоит отметить ключевое слово static, добавленное в PHP 8, которое 
	применяется, если надо возвратить из метода класса объект этого же класса */
	class Node
	{
		function generate() : static
		{
			return new Node();
		}
	}

	$node1 = new Node();
	$node2 = $node1 -> generate();

	//print_r($node1); //Node Object ( )
	echo "<br>";
	//print_r($node2); //Node Object ( )

	//-----------------[Типизация свойств]--------------------------------------

	class Person5
	{
		public $name; // равно null
		public int $age; // неинициализировано
	}

	$john = new Person5();
	$john -> name = "John";
	$john -> age = 36; //корректное значение
	//echo $john -> age; //36
	$john -> age = "36"; // корректное значение, так как PHP может преобразовать в число
	//echo $john -> age; //36
	//$john -> age = "thirty-six"; // некорректное значение, возникнет ошибка TypeError
	//echo $john -> age;

	/* свойство, для которого не указан тип данных, по умолчанию имеет значение 
	null. Тогда как свойство, для которого указан тип, неинициализировано, то 
	есть не имеет никакого конкретного значения. */

	$alec = new Person5();
	echo $alec -> name; // OK - null
	//var_dump($alec->name); // NULL

	//echo $alec -> age; // ошибка - свойство неинициализировано

	//-----------------[Тип Union]----------------------------------------------

	/* В PHP 8 был добавлен тип union или объединение, который по сути 
	представляет объединение типов, разделенных вертикальной чертой |. Например, 
	мы хотим написать функцию сложения чисел, и чтобы в функцию можно было 
	передавать только числа. Однако числа в PHP представлены двумя типами - int 
	и float. Чтобы не создавать по функции для каждого типа, применим объединения: */

	function sum1(int|float $n1, int|float $n2,): int|float
	{
		return $n1 + $n2;
	}

	//echo sum1(4, 5); //9
	echo "<br>";
	//echo sum1(2.5, 3.7); //6.2
	echo "<br>";
	//echo sum1(7, 5.5); //12.5
	
	/* В данном случае мы говорим, что параметры $n1 и $n2 могут представлять 
	как тип int, так и тип float. Аналогично возвращаемое значение также может 
	представлять либо int, либо float. */

//=====================[Работа со строками]=====================================

	$str1 = "Hello";
	$str2 = 'Welcome';

	$s = <<< LABEL
	Hello World!
	Bye World..
	LABEL;

	//echo $s; // Hello World! Bye World..


	$name3 = "Thomas";
	$age = 36;

	//$str3 = <<< USER
	//Name = $name3
	//Age = $age
	//USER;

	//echo $str3; // Name = Thomas Age = 36

	//-----------------[Обращение к символам строки]----------------------------

	$str4 = "Hello Eugene";

	//echo $str4[0]; //получим первый символ - H

	$str4[1] = "i"; // поменяем второй символ
	//echo "<br>" . $str4 . "<br>"; //Hillo Eugene

	//-----------------[Специальные функции и расширение mbstring]--------------

	//in php.ini
	//extension=mbstring
	//extension_dir = "./"

	//var_dump(extension_loaded('mbstring')); //bool(true)

	//-----------------[Функции strpos() и mb_strpos()]-------------------------

	/* Функция strpos($str, $search) возвращает позицию подстроки или 
	символа $search в строке $str или значение false, если строка $str не 
	содержит подстроки $search */

	$input = "This is the end";
	$search = "is";
	$position = strpos($input, $search); //2

	if($position !== false)
	{
		//echo "Позиция подстроки '$search' в строке '$input': $position <br>";
	}

	//another example

	$input1 = "Мама мыла раму";
	$search1 = "мы";
	$position1 = strpos($input1, $search1); //9

	/* некоторые строковые функции не всегда корректно обрабатывают 
	кириллические символы, и для них лучше использовать другую функцию - 
	mb_strpos(): */

	$position2 = mb_strpos($input1, $search1); //5

	//-----------------[Функция strrpos()]--------------------------------------
	
	/* Функция strrpos() во многом аналогична функции strpos(), только ищет 
	позицию не первого, а последнего вхождения подстроки в строку */

	$input2 = "This is the end";
	$search2 = "is";
	$position3 = strrpos($input2, $search2); //5

	// с кириллическими символами нужно использовать mb_strrpos()
	$position4 = mb_strrpos($input2, $search2);

	//-----------------[Функция trim()]-----------------------------------------

	/* Функция trim($str) удаляет из строки начальные и конечные пробелы, а 
	также управляющие символы \n, \r, \t */

	$input3 = "  Мама мыла раму   ";
	$input3 = trim($input3);

	//-----------------[Изменение регистра]-------------------------------------

	// Для перевода строки в нижний регистр используется функция strtolower
	
	$input4 = "The World is Mine";
	$input4 = strtolower($input4);
	//echo $input4; // the world is mine

	/* Для перевода в нижний регистр строки с кириллическими символами 
	используется функция mb_strtolower */

	/* Для перевода строки в верхний регистр применяются функции 
	strtoupper()/mb_ strtoupper() */

	$input4 = strtoupper($input4);
	//echo $input4; // THE WORLD IS MINE

	//-----------------[Функция strlen()]---------------------------------------

	// Функция strlen() возвращает длину строки, то есть количество символов в ней

	$input5 = "Hello World";
	$num = strlen($input5);
	//echo $num; // 11

	$input6 = "Мама мыла раму";
	$num1 = mb_strlen($input6);
	//echo $num1; // 14

	//-----------------[Получение подстроки]------------------------------------

	/* Применяя функцию substr($str, $start [, $length]), можно получить из 
	одной строки ее определенную часть. Данная функция обрезает строку $str, 
	начиная c символа в позиции $start до конца строки. С помощью 
	дополнительного необязательного параметра $length можно задать количество 
	вырезаемых символов. */

	$input7 = "The world is mine";
	$subinput1 = substr($input7, 2);
	$subinput2 = substr($input7, 2, 6);

	//echo $subinput1; // e world is mine
	//echo "<br>";
	//echo $subinput2; // e worl


	$input8 = "Король говорит";
	$subinput3 = mb_substr($input8, 7);
	$subinput4 = mb_substr($input8, 2, 10);

	//echo $subinput3; // говорит
	//echo "<br>";
	//echo $subinput4; // роль говор

	//-----------------[Замена подстрок]----------------------------------------

	/* Для замены определенной части строки применяется функция 
	str_replace($old, $new, $input). Эта функция заменяет в строке $input все 
	вхождения подстроки $old на подстроку $new с учетом регистра */

	$input9 = "Король говорит";
	$input9 = str_replace("говорит", "делает", $input9);
	//echo $input9; // Король делает

//=====================[Работа с cookie]========================================

	/* Cookie (куки) представляют небольшие наборы данных (не более 4 кБайт), 
	с помощью которых веб-сайт может сохранить на компьютере пользователя 
	любую информацию. С помощью куки можно отслеживать активность пользователя 
	на сайте: залогинен пользователь на сайте или нет, отслеживать историю его 
	визитов и т.д. */

	//-----------------[Сохранение cookie]--------------------------------------

	/* Для установки куки на компьютере пользователя используется функция 
	setcookie(). Она должна вызываться перед тем, как будет отправлен ответ 
	пользователю. Эта функция имеет следующее определение: 

	bool setcookie(string $name, string $value, int $expire, 
    string $path, string $domain, bool $secure, bool $httponly);

    Функция setcookie() может принимать следующие параметры:

	● name: имя cookie, которое будет использоваться для доступа к его значению

	● value: значение или содержимое cookie - любой алфавитно-цифровой текст не 
	более 4 кБайт

	● expire (необязательный параметр): срок действия в секундах, после которого 
	cookie уничтожаются. Если данный параметр не установлен или равен 0, то 
	уничтожение cookie происходит после закрытия браузера. Обычно 
	устанавливается относительно текущего времени, которое можно получить с 
	помощью функции time()

	● path (необязательный параметр): путь к каталогу на сервере, для которого 
	будут доступны cookie. Если задать "/", cookie будут доступны для всего 
	сайта. Если задать, например, "/mydir/", cookie будут доступны только из 
	каталога /mydir/ и всех его подкаталогов. По умолчанию значением является 
	текущий каталог, в котором устанавливаются cookie.

	● domain (необязательный параметр): задает домен, для которого будут 
	доступны cookie. Если это домен второго уровня, например, localhost.com, то 
	cookie доступны для всего сайта localhost.com, в том числе и для его 
	поддоменов типа blog.localhost.com.

	Если задан поддомен blog.localhost.com, то cookie доступны только внутри 
	этого поддомена.

	● secure (необязательный параметр): указывает на то, что значение cookie 
	должно передаваться по протоколу HTTPS. Если задано true, cookie от клиента 
	будет передано на сервер, только если установлено защищенное соединение. 
	По умолчанию равно false.

	● httponly (необязательный параметр): если равно true, cookie будут доступны 
	только через http протокол. То есть cookie в этом случае не будут доступны 
	скриптовым языкам, например, JavaScript. По умолчанию параметр равен false */

	$name4 = "Eugene";
	$age1 = 25;

	setcookie("name", $name4);
	setcookie("age", $age1, time() + 3600); // срок действия - 1 час (3600 секунд)
	//echo "cookie установлены <br>";

	/* Здесь устанавливаются две куки: "name" и "age". Первая куки уничтожается 
	после закрытия браузера, а вторая - через 3600 секунд, то есть через час. */

	//-----------------[Получение cookie]---------------------------------------

	//if (isset($_COOKIE["name"])) echo "Name: " . $_COOKIE["name"] . "<br>";
	//if (isset($_COOKIE["age"])) echo "Age: " . $_COOKIE["age"] . "<br>";

	//echo "<br><br>";

	//-----------------[Сохранение массивов в cookie]---------------------------

	setcookie("lang[1]", "PHP");
	setcookie("lang[2]", "C#");
	setcookie("lang[3]", "Java");

	if (isset($_COOKIE["lang"])) {
		foreach ($_COOKIE["lang"] as $name => $value) {
			$name = htmlspecialchars($name);
			$value = htmlspecialchars($value);
			//echo "$name. $value <br>";
		}
	}

	echo "<br>";

	//print_r($_COOKIE); 
	// Array ( [name] => Eugene [age] => 25 [lang] => Array ( [1] => PHP [2] => C# [3] => Java ) )

	//-----------------[Удаление cookie]----------------------------------------

	/* Для удаления cookie достаточно в качестве срока действия указать 
	какое-либо время в прошлом: */

	setcookie("name", "", time() - 3600);
	setcookie("age", "", time() - 3600);
	setcookie("lang[1]", "", time() - 3600);
	setcookie("lang[2]", "", time() - 3600);
	setcookie("lang[3]", "", time() - 3600);

//=====================[Сессии]=================================================

	/* Сессии представляют набор переменных, которые хранятся на сервере (либо 
	часть на сервере, а часть - в cookie браузера) и которые относятся только к 
	текущему пользователю. В какой-то степени сессии являются альтернативой 
	кукам в плане сохранения данных о пользователе.

	Для запуска сессии необходимо вызвать функцию session_start(). Она должна 
	вызываться до отправки ответа пользователю. */

	/* При запуске сессии с помощью функции session_start(), если пользователь 
	первый раз заходит на сайт, PHP назначает ему уникальный идентификатор 
	сессии. Этот идентификатор с помощью cookie, которые по умолчанию 
	называются "PHPSESSID", сохраняется в браузере пользователя. С помощью 
	этого идентификатора пользователь ассоциируется с данными сессии. Если для 
	пользователя уже установлена сессия, то данная функция продлевает текущую 
	сессию вместо установки новой. */

	session_start();
	echo session_id(); // идентификатор сессии
	echo "<br>";
	echo session_name(); // имя - PHPSESSID
	echo "<br>";
	echo $_COOKIE["PHPSESSID"] . "<br><br>"; //тоже значение идентификатора

	//-----------------[Сохранение данных в сессии]-----------------------------

	$_SESSION["name"] = "Eugene";
	$_SESSION["age"] = 25;
	echo "Данные сохранены в сессии <br><br>";

	print_r($_COOKIE); // Array ( [PHPSESSID] => 307dc9vrj0465aj3b71hr88up0 )
	echo "<br>";
	print_r($_SESSION); // Array ( [name] => Eugene [age] => 25 )
	echo "<br><br>";

	//-----------------[Получение данных сессии]--------------------------------

	if (isset($_SESSION["name"]) && isset($_SESSION["age"]))
	{
		$name5 = $_SESSION["name"];
		$age2 = $_SESSION["age"];
		echo "Name: $name5 <br> Age: $age2 <br>";
	}

	//-----------------[Удаление данных сессии]---------------------------------

	/* Сессия уничтожается с закрытием браузера, однако мы также можем 
	программно удалить либо какие-то отдельные, либо все данные сессии. */

	// Для удаления одной переменной из сессии применяется функция unset():

	unset($_SESSION["age"]); // удаляем из сессии переменную "age" 

	// Удалить все данные сессии можно с помощью функции session_destroy():

	//session_destroy();
	session_unset();

	/* по поводу session_destroy():

	После использования session_destroy() сеанс негласно уничтожается. По 
	какой-то причине это не влияет на значения в $_SESSION, который уже был 
	заполнен для этого запроса, но он будет пустым в будущих запросах.

	Вы можете очистить вручную, $_SESSION если хотите ( $_SESSION = []; ). */
?>
	




