<?php

		#+--------------------------------+
		#|          PHP 8.1.4             |
		#+--------------------------------+

#######################[Обработка исключений]###################################
		
//=====================[Конструкция try catch finally]==========================

	// Для обработки исключений в PHP применяется конструкция try-catch:
	try
	{
		// код, который может вызвать исключение
		$a = 5;
		$b = 0;
		$result = $a / $b;
		echo $result;
	}
	catch(DivisionByZeroError $ex)
	{
		// обработка исключения
		//echo "Произошло исключение:<br>";
		//echo $ex . "<br>";
	}

	//echo "Конец работы программы";

	//-----------------[Типы ошибок и исключений]-------------------------------

	/* В PHP для разных ситуаций есть множество типов, которые описывают ошибки. 
	Все эти встроенные типы применяют интерфейс Throwable:

							+---------------+
							|	Throwable	|
							+---------------+
								   ↑
		   		      _____________|_________________________
				     |								     	 |			
			     +-------+							 +---------------+
			     | Error |							 |	 Exception	 |
			     +-------+							 +---------------+
			         ↑
           __________|____________________________
 		  |                 |					  |
 	+-----------+     +------------+     +-----------------+ 
 	| TypeError |	  |	ParseError |	 | ArithmeticError |
	+-----------+     +------------+	 +-----------------+
												  ↑
												  |
									  +---------------------+
									  | DivisionByZeroError |
									  +---------------------+	

	Все типы делятся на две группы: собственно ошибки (класс Error) и собственно 
	исключения (класс Exception). А от классов Error и Exception наследуются 
	классы ошибок и исключений, которые описывают конкретные ситуации. Например, 
	от класса Error наследуется класс ArithmeticError, который описывает ошибки, 
	возникающие при выполнении арифметических операций. А от класса 
	ArithmeticError наследуется класс DivisionByZeroError, который представляют 
	ошибку при делении на ноль. */

	//-----------------[Блок catch]---------------------------------------------

	try
	{
		//$result1 = 5 / 0;
		//echo $result1;
	}
	catch(ParseError $p)
	{
		echo "Произошла ошибка парсинга";
	}
	catch(DivisionByZeroError $d)
	{
		echo "На ноль делить нельзя"; // <-
	}

	/* Блоки catch с более конкретными типами ошибок и исключениями должны идти 
	в начале, а с более общими типами - в конце: */

	try
	{
		//$result2 = 5 / 0;
		//echo $result2;
	}
	catch(DivisionByZeroError $ex)
	{
		echo "На ноль делить нельзя"; // <-
	}
	catch(ArithmeticError $ex)
	{
		echo "Ошибка при выполнении арифметической операции";
	}
	catch(Error $ex)
	{
		echo "Произошла ошибка";
	}
	catch(Throwable $ex)
	{
		echo "Ошибка при выполнении программы";
	}


	/* Если нам надо обрабатывать в принципе все ошибки и исключения, то мы 
	можем определить только обработку общего для всех них типа Throwable: */

	try
	{
		//$result3 = 5 / 0;
		//echo $result3;
	}
	catch(Throwable $ex)
	{
		echo "Ошибка при выполнении программы";
	}


	/* Начиная с версии PHP 8.0 в блоке catch можно просто указать тип 
	обрабатываемого исключения, не определяя переменную: */

	catch(DivisionByZeroError)
	{
		echo "Произошло исключение: деление на ноль";
	}

	//-----------------[Получение информации об ошибках и исключениях]----------

	/* Интерфейс Throwable предоставляет ряд методов, которые позволяют получить 
	некоторую информацию о возникшем исключении:

	getMessage(): возвращает сообщение об ошибке

	getCode(): возвращает код исключения

	getFile(): возвращает название файла, в котором возникла ошибка

	getLine(): возвращает номер строки, в которой возникла ошибка

	getTrace(): возвращает трассировку стека

	getTraceAsString(): возвращает трассировку стека в виде строки */

	try 
	{
		//$result4 = 5 / 0;
		//echo $result4;
	}
	catch(DivisionByZeroError $ex)
	{
		echo "Сообщение об ошибке: " . $ex -> getMessage() . "<br>";
		echo "Файл: " . $ex -> getFile() . "<br>";
		echo "Номер строки: " . $ex -> getLine() . "<br>";
	}

	/* output: 
	Сообщение об ошибке: Division by zero
	Файл: /home/eugene/localhost/metanit-php/4.exception_handling.php
	Номер строки: 146 
	*/

	//-----------------[Блок finally]-------------------------------------------

	/* Конструкция try..catch также может определять блок finally. Этот блок 
	выполняется в конце - после блока try и catch вне зависимости, возникла или 
	нет ошибка. Нередко блок finally используется для закрытия ресурсов, которые 
	применяются в блоке try. */

	try 
	{
		//$result5 = 5 / 0;
		//echo $result5;
	}
	catch(Throwable $ex)
	{
		echo "Ошибка при выполнении программы <br>";
	}
	finally
	{
		//echo "Блок finally <br>";
	}

	//echo "Конец работы программы";

	/* output:
	Ошибка при выполнении программы
	Блок finally
	Конец работы программы
	*/

	/* Конструкция try..catch..finally может содержать либо все три блока, либо 
	только два блока, try и либо блок catch, либо блок finally. */

//=====================[Генерация исключений]===================================

	/* Для генерации исключения применяется оператор throw, после которого 
	указывается объект исключения. */

	class Person
	{
		private $name, $age;

		function __construct($name, $age)
		{
			$this -> name = $name;
			if ($age < 0)
			{
				throw new Exception("Недействительный возраст");
			}
			$this -> age = $age;
		}

		function printInfo()
		{
			echo "Name: $this->name <br> Age: $this->age";
		}
	}

	//$tom = new Person("Tom", -105);
	//$tom -> printInfo();

	/* output:
	Fatal error: Uncaught Exception: Недействительный возраст in 
	/home/eugene/localhost/metanit-php/4.exception_handling.php:204 Stack 
	trace: #0 /home/eugene/localhost/metanit-php/4.exception_handling.php(216): 
	Person->__construct('Tom', -105) #1 {main} thrown in 
	/home/eugene/localhost/metanit-php/4.exception_handling.php on line 204 
	*/

	/* Поскольку вызов конструктора класса Person создает ситуацию, в которой 
	потенциально может возникнуть исключение, то лучше вызов конструктора 
	поместить в конструкцию try..catch: */

	try
	{
		$bob = new Person("Bob", -99);
		$bob -> printInfo();
	}
	catch(Exception $ex)
	{
		//echo $ex -> getMessage(); //Недействительный возраст
	}

	//-----------------[Создание классов исключений]----------------------------

	/* При генерации исключений мы можем полагаться на встроенные классы 
	исключений, как в примере с классом Exception выше. Однако может возникнуть 
	необходимость передать несколько больше информации при генерации или как-то 
	по своему настроить поведение класса исключения. В этом случае мы можем 
	создать свой класс исключения, заточенный под конкретные нужды: */

	class PersonInvalidAgeException extends Exception
	{
		function __construct($age)
		{
			$this -> message = "Недействительный возраст: $age. Возраст должен 
			быть в диапазоне от 0 до 120";
		}
	}

	class Person1
	{
		private $name, $age;
		function __construct($name, $age)
		{
			$this -> name = $name;
			if ($age < 0)
			{
				throw new PersonInvalidAgeException($age);
			}
			$this -> age = $age;
		}
		function printInfo()
		{
			echo "Name: $this->name <br> Age: $this->age";
		}
	}

	try
	{
		$eugene = new Person1("Eugene", -69);
		$eugene -> printInfo();
	}
	catch(PersonInvalidAgeException $ex)
	{
		echo $ex -> getMessage(); /* Недействительный возраст: -69. Возраст 
		должен быть в диапазоне от 0 до 120 */
	}

	/* (В реальности чтобы создать класс исключения, достаточно реализовать 
	интерфейс Throwable) */
?>

